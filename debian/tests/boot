#!/usr/bin/python3

"""Test that we can create an image from a model and it will boot.

We use QEMU to boot the image created by ubuntu-image.  We open the QMP
monitor port so that the controlling process (i.e. the autopkgtest) can start
and stop the virtual machine.

When creating the image, pass a very simple cloud-init user data file which
starts up a Python 3 echo server on port 8888 of the guest.  That port gets
forwarded to the host so that the autopkgtest (i.e. this script) can connect
to it.  We send the echo server some data, get the results, and if they match,
we're good.

NOTE: This test only runs on amd64!
"""

import os
import time
import platform

from contextlib import ExitStack
from datetime import datetime, timedelta
from json import dumps, loads
from random import randrange
from socket import create_connection
from subprocess import run
from tempfile import TemporaryDirectory
from threading import Thread


TMP = os.environ['AUTOPKGTEST_TMP']
DIR = os.path.abspath(os.path.join('debian', 'tests', 'models'))
QMP_TIMEOUT = 60 # seconds
SSH_TIMEOUT = 60 * 3
NEWLINE = b'\n'

GREETING = b'this is the autopkgtest boot test'


def qemu(image, qmp_port, fwd_port):
    run(['qemu-system-x86_64',
         '-qmp', 'tcp:localhost:{},server'.format(qmp_port),
         '-nographic',
         '-m', '2G',
         '-netdev', 'user,id=mynet0,hostfwd=::{}-:8888'.format(fwd_port),
         '-device', 'e1000,netdev=mynet0',
         image],
        check=True)


def execute(conn, command=None):
    # This is a very stupid, low-level way to talk QMP, but who cares?  This
    # is just a throwaway test in a controlled environment so it doesn't have
    # to be super robust.  FYI, I couldn't get telnetlib.Telnet to work, even
    # though you can command-line telnet to QMP.  We should probably use
    # asyncio.
    if command is not None:
        encoded_command = dumps(dict(execute=command)).encode('utf-8')
        conn.sendall(encoded_command)
    received = conn.recv(4096).decode('utf-8')
    responses = [loads(line) for line in received.splitlines()]
    assert len(responses) == 1, responses
    return responses[0]


def shutdown(conn):
    try:
        # Try to shut QEMU down cleanly.  This may or may not succeed, and it
        # may not even provide a response if it does succeed.  No matter, since
        # the autopkgtest infrastructure will tear down all the resources any
        # way.  Still, I like to at least try!
        execute('quit')
    except:
        conn.close()


def main():
    # First off, can we even run the test on this architecture?
    if platform.machine() != 'x86_64':
        # We can't but it makes no sense to fail.
        sys.exit(0)
    # Use ubuntu-image to create an image.  Use cloud-init to initialize the
    # instance (so it doesn't print 'Press enter to configure.' and wait for
    # user input).
    with TemporaryDirectory() as tmpdir:
        user_data_file = os.path.join(tmpdir, 'user-data.txt')
        with open(user_data_file, 'w', encoding='utf-8') as fp:
            print("""\
write_files:
 - content: |
      #!/usr/bin/python3
      import asyncio
      print('Starting echo service')
      class EchoServerClientProtocol(asyncio.Protocol):
          def connection_made(self, transport):
              peername = transport.get_extra_info('peername')
              print('Connection from {}'.format(peername))
              self.transport = transport
          def data_received(self, data):
              message = data.decode()
              print('Data received: {!r}'.format(message))
              print('Send: {!r}'.format(message))
              self.transport.write(data)
              print('Close the client socket')
              self.transport.close()
      loop = asyncio.get_event_loop()
      # Each client connection will create a new protocol instance
      coro = loop.create_server(EchoServerClientProtocol, '127.0.0.1', 8888)
      server = loop.run_until_complete(coro)
      # Serve requests until Ctrl+C is pressed
      print('Serving on {}'.format(server.sockets[0].getsockname()))
      try:
          loop.run_forever()
      except KeyboardInterrupt:
          pass
      # Close the server
      server.close()
      loop.run_until_complete(server.wait_closed())
      loop.close()
   path: /usr/bin/echo
   permissions:  '0777'
bootcmd:
  - /usr/bin/echo
""", file=fp)
        image_file = os.path.join(tmpdir, 'image-file-list.txt')
        run(['ubuntu-image', '--image-file-list', image_file,
             '--output-dir', TMP,
             '--cloud-init', user_data_file,
             os.path.join(DIR, 'pc-amd64-model.assertion')],
            check=True)
        with open(image_file, 'r', encoding='utf-8') as fp:
            images = [line.rstrip() for line in fp.readlines()]
            assert len(images) == 1, images
    image = images[0]
    # Assume that we can find a random port between [10000-20000) - if we
    # can't, no biggie, the test may fail but we can always retry it.
    qmp_port = randrange(10000, 15000)
    fwd_port = randrange(20000, 25000)
    with ExitStack() as resources:
        thread = Thread(target=qemu, args=(image, qmp_port, fwd_port))
        thread.daemon = True
        thread.start()
        # Connect to QMP, but watch out for the race condition.  Connecting
        # will start the boot process for the VM.
        until = datetime.now() + timedelta(seconds=QMP_TIMEOUT)
        while datetime.now() < until:
            # No, the timeout argument to this function does *not* handle
            # ConnectionRefusedErrors.
            try:
                qmp = create_connection(('localhost', qmp_port))
                break
            except ConnectionRefusedError:
                time.sleep(0.1)
        else:
            raise RuntimeError('Cannot connect to QMP port')
        resources.callback(shutdown, qmp)
        # Read off the boot response, which we don't care about.
        execute(qmp)
        # Tell QEMU we want to talk to it.
        results = execute(qmp, 'qmp_capabilities')
        assert results == {'return': {}}, results
        # Connect to the SSH service.
        until = datetime.now() + timedelta(seconds=SSH_TIMEOUT)
        while datetime.now() < until:
            # No, the timeout argument to this function does *not* handle
            # ConnectionRefusedErrors.
            try:
                echo = create_connection(('localhost', fwd_port))
                break
            except ConnectionRefusedError:
                time.sleep(0.1)
        else:
            raise RuntimeError('Cannot connect to SSH port')
        resources.callback(echo.close)
        echo.sendall(GREETING)
        response = echo.recv(4096)
        assert response == GREETING, response


main()
