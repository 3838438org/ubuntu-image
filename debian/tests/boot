#!/usr/bin/python3

"""Test that we can create an image from a model and it will boot.

We use QEMU to boot the image created by ubuntu-image.  We open the QMP
monitor port so that the controlling process (i.e. the autopkgtest) can start
and stop the virtual machine.

When creating the image, pass an extra snap that implements a very simple case
swapping echo service.  This service starts on image boot and listens on port
8888 of the guest.  That port gets forwarded to the host so that the
autopkgtest (i.e. this script) can connect to it.  We send the echo server some
bytes data and check the response.

NOTE: This test only runs on amd64!
"""

import os
import time
import platform

from contextlib import ExitStack
from datetime import datetime, timedelta
from json import dumps, loads
from pprint import pprint
from random import randrange
from socket import create_connection
from subprocess import run
from tempfile import TemporaryDirectory
from threading import Thread


TMP = os.environ['AUTOPKGTEST_TMP']
DIR = os.path.abspath(os.path.join('debian', 'tests', 'models'))
QMP_TIMEOUT = 60 # seconds
SSH_TIMEOUT = 60 * 3
NEWLINE = b'\n'
GREETING = b'this is the autopkgtest boot test'

extra_snap = os.path.abspath(
    os.path.join('debian', 'tests', 'snaps', 'echo-service_0.2_amd64.snap'))


def qemu(image):
    run(['qemu-system-x86_64',
         '-qmp', 'tcp:localhost:4444,server',
         '-nographic',
         '-m', '500M',
         '-netdev', 'user,id=mynet0,hostfwd=::8888-:8888,hostfwd=::9922-:22',
         '-device', 'e1000,netdev=mynet0',
         image],
        check=True)


CLOUD_INIT = """\
users:
 - default
 - name: debug
   gecos: Debug
   passwd: jiPZFMQONuVas
   home: /home/debug
   shell: /bin/bash
   lock_passwd: false
   groups: [adm, audio, cdrom, dialout, floppy, video, plugdev, dip, netdev]
   sudo: ALL=(ALL) NOPASSWD:ALL
manage-resolve-conf: true
resolve_conf:
  nameservers: ['8.8.4.4', '8.8.8.8']
"""


def build_image():
    # Use ubuntu-image to create an image with a local extra snap that
    # implements an echo service.  This service starts on image boot.
    image_file = os.path.join(TMP, 'image-file-list.txt')
    user_data = os.path.join(TMP, 'cloud-init.yml')
    with open(user_data, 'w', encoding='utf-8') as fp:
        print(CLOUD_INIT, file=fp)
    run(['ubuntu-image', '--image-file-list', image_file,
         '--output-dir', TMP,
         '--workdir', TMP,
         '--extra-snaps', extra_snap,
         # XXX DEBUGGING HACK.
         '--cloud-init', user_data,
         '--thru', 'populate_rootfs_contents',
         os.path.join(DIR, 'pc-amd64-model.assertion')],
        check=True)
    os.remove(os.path.join(
        TMP, 'root', 'system-data', 'etc', 'cloud', 'cloud-init.disabled'))
    run(['ubuntu-image', '--resume', '--workdir', TMP,
         '--image-file-list', image_file,
         '--output-dir', TMP],
        check=True)
    with open(image_file, 'r', encoding='utf-8') as fp:
        images = [line.rstrip() for line in fp.readlines()]
        assert len(images) == 1, images
    return images[0]


def execute(conn, command=None):
    # This is a very stupid, low-level way to talk QMP, but who cares?  This
    # is just a throwaway test in a controlled environment so it doesn't have
    # to be super robust.  FYI, I couldn't get telnetlib.Telnet to work, even
    # though you can command-line telnet to QMP.  We should probably use
    # asyncio.
    if command is not None:
        encoded_command = dumps(dict(execute=command)).encode('utf-8')
        conn.sendall(encoded_command)
    received = conn.recv(4096).decode('utf-8')
    responses = [loads(line) for line in received.splitlines()]
    assert len(responses) == 1, responses
    return responses[0]


def shutdown(conn):
    try:
        # Try to shut QEMU down cleanly.  This may or may not succeed, and it
        # may not even provide a response if it does succeed.  No matter, since
        # the autopkgtest infrastructure will tear down all the resources any
        # way.  Still, I like to at least try!
        execute('quit')
    except:
        conn.close()


def main():
    # First off, can we even run the test on this architecture?
    if platform.machine() != 'x86_64':
        # We can't but it makes no sense to fail.
        sys.exit(0)
    image = build_image()
    with ExitStack() as resources:
        thread = Thread(target=qemu, args=(image,))
        thread.daemon = True
        thread.start()
        # Connect to QMP, but watch out for the race condition.  Connecting
        # will start the boot process for the VM.
        until = datetime.now() + timedelta(seconds=QMP_TIMEOUT)
        while datetime.now() < until:
            # No, the timeout argument to this function does *not* handle
            # ConnectionRefusedErrors.
            try:
                qmp = create_connection(('localhost', 4444))
                break
            except ConnectionRefusedError:
                time.sleep(0.1)
        else:
            raise RuntimeError('Cannot connect to QMP port')
        resources.callback(shutdown, qmp)
        # Read off the boot response, which we don't care about.
        execute(qmp)
        # Tell QEMU we want to talk to it.
        results = execute(qmp, 'qmp_capabilities')
        assert results == {'return': {}}, results
        # Connect to the SSH service.
        until = datetime.now() + timedelta(seconds=SSH_TIMEOUT)
        while datetime.now() < until:
            # No, the timeout argument to this function does *not* handle
            # ConnectionRefusedErrors.
            try:
                echo = create_connection(('localhost', 8888))
                break
            except ConnectionRefusedError:
                time.sleep(0.1)
        else:
            raise RuntimeError('Cannot connect to SSH port')
        resources.callback(echo.close)
        echo.sendall(GREETING)
        response = echo.recv(4096)
        assert response == GREETING.swapcase(), response


main()
