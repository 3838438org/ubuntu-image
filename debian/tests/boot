#!/usr/bin/python3

"""Test that we can create an image from a model and it will boot.

We use QEMU to boot the image created by ubuntu-image.  We open the QMP
monitor port so that the controlling process (i.e. the autopkgtest) can start
and stop the virtual machine.

When creating the image, pass a very simple extra snap that implements an echo
service.  This services starts on image boot and listens on port 8888 of the
guest.  That port gets forwarded to the host so that the autopkgtest (i.e. this
script) can connect to it.  We send the echo server some data, get the results,
and if they match, we're good.

NOTE: This test only runs on amd64!
"""

import os
import time
import platform

from contextlib import ExitStack
from datetime import datetime, timedelta
from json import dumps, loads
from random import randrange
from socket import create_connection
from subprocess import run
from tempfile import TemporaryDirectory
from threading import Thread


TMP = os.environ['AUTOPKGTEST_TMP']
DIR = os.path.abspath(os.path.join('debian', 'tests', 'models'))
QMP_TIMEOUT = 60 # seconds
SSH_TIMEOUT = 60 * 3
NEWLINE = b'\n'
GREETING = b'this is the autopkgtest boot test'

extra_snap = os.path.abspath(
    os.path.join('debian', 'tests', 'snaps', 'echo-service_0.2_amd64.snap'))


def qemu(image, qmp_port, fwd_port):
    print('RUNNING IMAGE: qmp={}, fwd={}'.format(qmp_port, fwd_port))
    run(['qemu-system-x86_64',
         '-qmp', 'tcp:localhost:{},server'.format(qmp_port),
         '-nographic',
         '-m', '500M',
         '-netdev', 'user,id=mynet0,hostfwd=::{}-:8888'.format(fwd_port),
         '-device', 'e1000,netdev=mynet0',
         image],
        check=True)


def execute(conn, command=None):
    # This is a very stupid, low-level way to talk QMP, but who cares?  This
    # is just a throwaway test in a controlled environment so it doesn't have
    # to be super robust.  FYI, I couldn't get telnetlib.Telnet to work, even
    # though you can command-line telnet to QMP.  We should probably use
    # asyncio.
    if command is not None:
        encoded_command = dumps(dict(execute=command)).encode('utf-8')
        conn.sendall(encoded_command)
    received = conn.recv(4096).decode('utf-8')
    responses = [loads(line) for line in received.splitlines()]
    assert len(responses) == 1, responses
    return responses[0]


def shutdown(conn):
    try:
        # Try to shut QEMU down cleanly.  This may or may not succeed, and it
        # may not even provide a response if it does succeed.  No matter, since
        # the autopkgtest infrastructure will tear down all the resources any
        # way.  Still, I like to at least try!
        execute('quit')
    except:
        conn.close()


def main():
    # First off, can we even run the test on this architecture?
    if platform.machine() != 'x86_64':
        # We can't but it makes no sense to fail.
        sys.exit(0)
    # Use ubuntu-image to create an image with a local extra snap that
    # implements an echo service.  This service starts on image boot.
    image_file = os.path.join(TMP, 'image-file-list.txt')
    run(['ubuntu-image', '--image-file-list', image_file,
         '--output-dir', TMP,
         '--extra-snaps', extra_snap,
         os.path.join(DIR, 'pc-amd64-model.assertion')],
        check=True)
    with open(image_file, 'r', encoding='utf-8') as fp:
        images = [line.rstrip() for line in fp.readlines()]
        assert len(images) == 1, images
    image = images[0]
    # Assume that we can find a random port between [10000-20000) - if we
    # can't, no biggie, the test may fail but we can always retry it.
    qmp_port = randrange(10000, 15000)
    fwd_port = randrange(20000, 25000)
    with ExitStack() as resources:
        thread = Thread(target=qemu, args=(image, qmp_port, fwd_port))
        thread.daemon = True
        thread.start()
        # Connect to QMP, but watch out for the race condition.  Connecting
        # will start the boot process for the VM.
        until = datetime.now() + timedelta(seconds=QMP_TIMEOUT)
        while datetime.now() < until:
            # No, the timeout argument to this function does *not* handle
            # ConnectionRefusedErrors.
            try:
                qmp = create_connection(('localhost', qmp_port))
                break
            except ConnectionRefusedError:
                time.sleep(0.1)
        else:
            raise RuntimeError('Cannot connect to QMP port')
        resources.callback(shutdown, qmp)
        # Read off the boot response, which we don't care about.
        execute(qmp)
        # Tell QEMU we want to talk to it.
        results = execute(qmp, 'qmp_capabilities')
        assert results == {'return': {}}, results
        # Connect to the SSH service.
        until = datetime.now() + timedelta(seconds=SSH_TIMEOUT)
        while datetime.now() < until:
            # No, the timeout argument to this function does *not* handle
            # ConnectionRefusedErrors.
            try:
                echo = create_connection(('localhost', fwd_port))
                break
            except ConnectionRefusedError:
                time.sleep(0.1)
        else:
            raise RuntimeError('Cannot connect to SSH port')
        resources.callback(echo.close)
        echo.sendall(GREETING)
        time.sleep(5)
        response = echo.recv(4096)
        assert response == GREETING.swapcase(), response


main()
